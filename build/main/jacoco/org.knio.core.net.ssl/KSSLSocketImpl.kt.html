<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KSSLSocketImpl.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">knio-core</a> &gt; <a href="index.source.html" class="el_package">org.knio.core.net.ssl</a> &gt; <span class="el_source">KSSLSocketImpl.kt</span></div><h1>KSSLSocketImpl.kt</h1><pre class="source lang-java linenums">package org.knio.core.net.ssl

import kotlinx.coroutines.delay
import kotlinx.coroutines.sync.withLock
import org.knio.core.nio.readSuspend
import org.knio.core.nio.writeSuspend
import org.knio.core.context.KnioContext
import org.knio.core.context.ReleasableBuffer
import org.knio.core.context.acquireReleasableByteBuffer
import org.knio.core.io.KInputStream
import org.knio.core.io.KOutputStream
import java.io.IOException
import java.net.SocketException
import java.nio.ByteBuffer
import java.nio.channels.AsynchronousSocketChannel
import java.nio.channels.ClosedChannelException
import javax.net.ssl.*
import kotlin.math.min

<span class="fc" id="L20">internal class KSSLSocketImpl (</span>
    channel: AsynchronousSocketChannel,
    sslEngine: SSLEngine,
    useClientMode: Boolean,
<span class="fc" id="L24">    private val context: KnioContext</span>
<span class="fc" id="L25">): KSSLSocketAbstract(</span>
<span class="fc" id="L26">    channel,</span>
<span class="fc" id="L27">    sslEngine,</span>
<span class="fc" id="L28">    useClientMode</span>
) {

    private var isInputShutdown = false
<span class="fc" id="L32">    private val networkRead = ReadWriteBuffer(context.byteBufferPool.acquireReleasableByteBuffer(sslEngine.session.packetBufferSize).apply { value.limit(0) })</span>
<span class="fc" id="L33">    private val application = ReadWriteBuffer(context.byteBufferPool.acquireReleasableByteBuffer(sslEngine.session.applicationBufferSize).apply { value.limit(0) })</span>

    private var isOutputShutdown = false
<span class="fc" id="L36">    private var networkWrite = ReadWriteBuffer(context.byteBufferPool.acquireReleasableByteBuffer(sslEngine.session.packetBufferSize).apply { value.limit(0) })</span>

<span class="fc" id="L38">    private val inputStream = object : KInputStream(context) {</span>

        override suspend fun read(b: ByteBuffer): Int {
<span class="fc" id="L41">            return this@KSSLSocketImpl.read(b)</span>
        }

        override suspend fun close() {
<span class="fc" id="L45">            this@KSSLSocketImpl.close()</span>
<span class="fc" id="L46">        }</span>
    }

<span class="fc" id="L49">    private val outputStream = object : KOutputStream() {</span>
        override suspend fun write(b: ByteBuffer) {
<span class="fc" id="L51">            this@KSSLSocketImpl.write(b)</span>
<span class="fc" id="L52">        }</span>

        override suspend fun close() {
<span class="fc" id="L55">            this@KSSLSocketImpl.close()</span>
<span class="fc" id="L56">        }</span>
    }

<span class="fc" id="L59">    override suspend fun getInputStream(): KInputStream = lock.withLock {</span>
<span class="fc bfc" id="L60" title="All 2 branches covered.">        if(!ch.isOpen) {</span>
<span class="fc" id="L61">            throw SocketException(&quot;Socket is closed&quot;)</span>
        }
<span class="fc bfc" id="L63" title="All 2 branches covered.">        if(isInputShutdown) {</span>
<span class="fc" id="L64">            throw SocketException(&quot;Socket input is shutdown&quot;)</span>
        }
<span class="fc" id="L66">        return inputStream</span>
    }

<span class="fc" id="L69">    override suspend fun getOutputStream(): KOutputStream = lock.withLock {</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">        if(isOutputShutdown) {</span>
<span class="fc" id="L71">            throw SocketException(&quot;Socket output is shutdown&quot;)</span>
        }
<span class="fc" id="L73">        return outputStream</span>
    }

    override suspend fun softStartHandshake() {
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">        if(!sslEngine.session.isValid) {</span>
<span class="pc" id="L78">            startHandshake0()</span>
        }
<span class="nc" id="L80">    }</span>

<span class="fc" id="L82">    override suspend fun startHandshake() = lock.withLock {</span>
        // initiates or renegotiates the SSL handshake
<span class="fc" id="L84">        startHandshake0()</span>
<span class="fc" id="L85">    }</span>

    /**
     * Same as [KSSLSocket.startHandshake] except that this is an internal function that executes without
     * acquiring the lock.
     *
     * @see [KSSLSocket.startHandshake]
     */
    private suspend fun startHandshake0() {
        @Suppress(&quot;BlockingMethodInNonBlockingContext&quot;)
<span class="fc" id="L95">        sslEngine.beginHandshake()</span>
<span class="pc" id="L96">        handleHandshake0()</span>
<span class="nc" id="L97">    }</span>

    /**
     * Handles the handshake process.
     *
     * A handshake may be initiated at any time, and may be initiated multiple times. This method will handle processing
     * the handshake until it is complete.
     */
<span class="fc" id="L105">    private suspend fun handleHandshake0(force: Boolean = false) {</span>
        /**
         * In rare situations, a handshake may be triggered with NEEDS_TASK, NEEDS_WRAP or NEEDS_UNWRAP but will never
         * materialize into a full handshake session.
         *
         * Perform the required task then return unless a handshake session is available. If a handshake session is
         * available, then the handshake is in progress and we should continue.
         */

<span class="pc bpc" id="L114" title="1 of 2 branches missed.">        if(!sslEngine.isHandshaking) {</span>
<span class="nc" id="L115">            return</span>
        }

<span class="fc" id="L118">        var handshakeSession: SSLSession? = sslEngine.handshakeSession</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">        handshakeSession?.let { initBuffersForHandshake(it) }</span>

        do {
<span class="fc" id="L122">            handshakeIteration0()</span>
<span class="fc bfc" id="L123" title="All 4 branches covered.">            handshakeSession = handshakeSession ?: sslEngine.handshakeSession?.also { initBuffersForHandshake(it) }</span>
<span class="fc bfc" id="L124" title="All 6 branches covered.">        } while (sslEngine.isHandshaking &amp;&amp; (handshakeSession != null || !sslEngine.session.isValid))</span>


<span class="fc bfc" id="L127" title="All 2 branches covered.">        if(handshakeSession != null) {</span>
<span class="fc" id="L128">            super.triggerHandshakeCompletion(handshakeSession)</span>
        }
<span class="fc" id="L130">    }</span>

    private suspend fun initBuffersForHandshake(session: SSLSession) {
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">        if(networkRead.value.capacity()&lt;session.packetBufferSize) {</span>
<span class="nc" id="L134">            networkRead.releasable.resize(session.packetBufferSize)</span>
        }
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">        if(networkWrite.value.capacity()&lt;session.packetBufferSize) {</span>
<span class="nc" id="L137">            networkWrite.releasable.resize(session.packetBufferSize)</span>
        }
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">        if(application.value.capacity()&lt;session.applicationBufferSize) {</span>
<span class="nc" id="L140">            application.releasable.resize(session.applicationBufferSize)</span>
        }
<span class="fc" id="L142">    }</span>

    private suspend fun handshakeIteration0() {
<span class="pc bpc" id="L145" title="1 of 4 branches missed.">        when(sslEngine.handshakeStatus!!) {</span>
            SSLEngineResult.HandshakeStatus.NEED_TASK -&gt; {
<span class="fc" id="L147">                runHandshakeTasks()</span>
            }
            SSLEngineResult.HandshakeStatus.NEED_WRAP -&gt; {
<span class="fc" id="L150">                wrapHandshake()</span>
            }
            SSLEngineResult.HandshakeStatus.NEED_UNWRAP,
            SSLEngineResult.HandshakeStatus.NEED_UNWRAP_AGAIN-&gt; {
<span class="fc" id="L154">                unwrapHandshake()</span>
            }
            SSLEngineResult.HandshakeStatus.FINISHED,
            SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING -&gt; {
                // DONE!
            }
        }
<span class="pc" id="L161">    }</span>

    private fun runHandshakeTasks() {
<span class="fc" id="L164">        while (true) {</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">            val task = sslEngine.delegatedTask ?: break</span>
<span class="fc" id="L166">            task.run()</span>
        }
<span class="fc" id="L168">    }</span>

    private suspend fun wrapHandshake() {
<span class="fc" id="L171">        wrap(src = ByteBuffer.wrap(ByteArray(0)))</span>
<span class="fc" id="L172">    }</span>

<span class="fc" id="L174">    private suspend fun wrap (</span>
        src: ByteBuffer,
<span class="fc" id="L176">        dst: ReadWriteBuffer = networkWrite</span>
    ) {
<span class="fc" id="L178">        while (true) {</span>
<span class="fc" id="L179">            @Suppress(&quot;BlockingMethodInNonBlockingContext&quot;)</span>
<span class="fc" id="L180">            val result = sslEngine.wrap(src, dst.write)</span>

<span class="pc bpc" id="L182" title="2 of 4 branches missed.">            when (result.status!!) {</span>
                SSLEngineResult.Status.BUFFER_UNDERFLOW -&gt; {
                    // Dummy buffer used. If thrown, bad assumptions made
<span class="nc" id="L185">                    throw SSLException(&quot;Buffer underflow while wrapping in handshake&quot;)</span>
                }

                SSLEngineResult.Status.BUFFER_OVERFLOW -&gt; {
<span class="nc" id="L189">                    handleOverflow(dst)</span>
                }

                SSLEngineResult.Status.OK -&gt; {
                    // Unwrap was successful. Write the data to the channel.
<span class="fc" id="L194">                    dst.toMode(ReadWriteBuffer.Mode.READ)</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">                    while (dst.value.hasRemaining()) {</span>
<span class="fc" id="L196">                        val read = ch.writeSuspend(dst.value, getWriteTimeout())</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">                        if (read == -1) {</span>
<span class="nc" id="L198">                            throw SSLException(&quot;Connection closed during handshake&quot;)</span>
                        }
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">                        if (read == 0) {</span>
                            // TODO
<span class="nc" id="L202">                            throw SSLException(&quot;?? no data written during handshake. try again or error ??&quot;)</span>
                        }
                    }
<span class="fc" id="L205">                    break</span>
                }

                SSLEngineResult.Status.CLOSED -&gt; {
                    // closed
<span class="fc" id="L210">                    throw SSLException(&quot;Connection closed during handshake&quot;)</span>
                }
            }
        }
<span class="fc" id="L214">    }</span>

    private suspend fun unwrapHandshake() {

<span class="fc" id="L218">        while (true) {</span>
            // try to unwrap data from the network buffer

<span class="fc" id="L221">            @Suppress(&quot;BlockingMethodInNonBlockingContext&quot;)</span>
<span class="fc" id="L222">            val result = sslEngine.unwrap(networkRead.read, application.write)</span>

<span class="pc bpc" id="L224" title="2 of 4 branches missed.">            when (result.status!!) {</span>
                SSLEngineResult.Status.BUFFER_UNDERFLOW -&gt; {
                    // If there's no room to read, increase buffer size
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">                    if (!networkRead.write.hasRemaining()) {</span>
<span class="nc" id="L228">                        val buffer = networkRead.releasable</span>
<span class="nc" id="L229">                        buffer.resize(buffer.value.capacity() + sslEngine.session.packetBufferSize)</span>
                    }

                    // Read more data from the channel
<span class="fc" id="L233">                    val count = ch.readSuspend(networkRead.write, getReadTimeout())</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">                    if (count == -1) {</span>
<span class="fc" id="L235">                        throw SSLException(&quot;Connection closed during handshake&quot;)</span>
                    }
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">                    if (count == 0) {</span>
<span class="nc" id="L238">                        throw SSLException(&quot;?? no data read during handshake. try again or error ??&quot;)</span>
                    }
                }

                SSLEngineResult.Status.BUFFER_OVERFLOW -&gt; {
<span class="nc" id="L243">                    handleOverflow(networkRead)</span>
                }

                SSLEngineResult.Status.OK -&gt; {
                    // unwrap was successful. leave the data in the network buffer for the next unwrap
<span class="fc" id="L248">                    break</span>
                }

                SSLEngineResult.Status.CLOSED -&gt; {
                    // closed
<span class="nc" id="L253">                    throw SSLException(&quot;Connection closed during handshake&quot;)</span>
                }
            }
        }
<span class="fc" id="L257">    }</span>

    /**
     * Handles the BUFFER_OVERFLOW scenario when wrapping or unwrapping ssl content.
     *
     */
    private fun handleOverflow(buffer: ReadWriteBuffer) {
        /**
         * The buffer should be in write mode.  That is, it's adding data to the buffer.
         * The data already in the buffer, from index 0 to index `position()` is data
         * written, waiting to be processed. The data from `position()+1` to `limit()`
         * is the space we're allowed to write. The space from `limit()` to `capacity()`
         * is unusable space.
         */

<span class="nc bnc" id="L272" title="All 2 branches missed.">        require(buffer.mode.isWrite())</span>

<span class="nc" id="L274">        val limit = buffer.value.limit()</span>
<span class="nc" id="L275">        val capacity = buffer.value.capacity()</span>

<span class="nc bnc" id="L277" title="All 2 branches missed.">        if (limit == capacity) {</span>
            /**
             * If limit is capacity, then the wrap/unwrap failed with the maximum amount of space.
             * We need to make the buffer bigger.
             */

<span class="nc" id="L283">            buffer.releasable.resize(capacity + sslEngine.session.packetBufferSize)</span>
        } else {
            /**
             * If limit is not capacity, then there's unused space. Utilize that space and try
             * again
             */

<span class="nc" id="L290">            buffer.value.limit(capacity)</span>
        }
<span class="nc" id="L292">    }</span>

<span class="nc" id="L294">    override suspend fun isInputShutdown(): Boolean = lock.withLock {</span>
<span class="nc" id="L295">        return isInputShutdown</span>
    }

<span class="nc" id="L298">    override suspend fun isOutputShutdown(): Boolean = lock.withLock {</span>
<span class="nc" id="L299">        return isOutputShutdown</span>
    }

<span class="fc" id="L302">    override suspend fun shutdownInput() = lock.withLock {</span>
<span class="fc" id="L303">        shutdownInput0()</span>
<span class="fc" id="L304">    }</span>

    private suspend fun shutdownInput0() {
<span class="fc bfc" id="L307" title="All 2 branches covered.">        if(networkRead.releasable.released) {</span>
<span class="fc" id="L308">            return</span>
        }

<span class="fc" id="L311">        try {</span>
<span class="fc" id="L312">            try {</span>
                @Suppress(&quot;BlockingMethodInNonBlockingContext&quot;)
<span class="fc" id="L314">                sslEngine.closeInbound()</span>
<span class="fc" id="L315">            } catch (e: SSLException) {</span>
                // ignore
            }

            // Clear buffer for reuse or release
<span class="fc" id="L320">            networkRead.value.clear()</span>
        } finally {
<span class="fc" id="L322">            isInputShutdown = true</span>
<span class="fc" id="L323">            networkRead.releasable.release()</span>
        }
<span class="fc" id="L325">    }</span>

<span class="fc" id="L327">    override suspend fun shutdownOutput() = lock.withLock {</span>
<span class="fc" id="L328">        shutdownOutput0()</span>
<span class="fc" id="L329">    }</span>

    private suspend fun shutdownOutput0() {
<span class="fc" id="L332">        try {</span>
<span class="fc" id="L333">            sslEngine.closeOutbound()</span>

<span class="fc" id="L335">            out@ while (true) {</span>
<span class="fc" id="L336">                @Suppress(&quot;BlockingMethodInNonBlockingContext&quot;)</span>
<span class="fc" id="L337">                val result = sslEngine.wrap(ByteBuffer.allocate(0), networkWrite.write)</span>

<span class="pc bpc" id="L339" title="3 of 4 branches missed.">                when (result.status!!) {</span>

                    SSLEngineResult.Status.BUFFER_OVERFLOW -&gt; {
<span class="nc" id="L342">                        handleOverflow(networkWrite)</span>
                    }

                    SSLEngineResult.Status.OK -&gt; {
<span class="nc" id="L346">                        try {</span>
<span class="nc" id="L347">                            networkWrite.toMode(ReadWriteBuffer.Mode.READ)</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">                            while (networkWrite.value.hasRemaining()) {</span>
<span class="nc" id="L349">                                var written = 0</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">                                repeat(3) { attempt -&gt;</span>
<span class="nc" id="L351">                                    written = ch.writeSuspend(networkWrite.value)</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">                                    if (written &gt; 0) return@repeat</span>
<span class="nc" id="L353">                                    delay(100L * attempt) // Backoff delay</span>
<span class="nc" id="L354">                                }</span>

<span class="nc bnc" id="L356" title="All 2 branches missed.">                                if (written &lt;= 0) {</span>
<span class="nc" id="L357">                                    break@out</span>
                                }
                            }
<span class="nc" id="L360">                            networkWrite.value.clear()</span>
<span class="nc" id="L361">                            break</span>
<span class="nc" id="L362">                        } catch (e: ClosedChannelException) {</span>
                            // ignore
<span class="nc" id="L364">                        } catch (e: IOException) {</span>
<span class="nc" id="L365">                            throw e</span>
                        }
                    }

                    SSLEngineResult.Status.CLOSED -&gt; {
                        // closed
<span class="fc" id="L371">                        break@out</span>
                    }

                    else -&gt; {
<span class="nc" id="L375">                        throw SSLException(&quot;Unexpected SSL wrap status: ${result.status}&quot;)</span>
                    }
                }
            }

<span class="fc" id="L380">            try {</span>
                @Suppress(&quot;BlockingMethodInNonBlockingContext&quot;)
<span class="fc" id="L382">                ch.shutdownOutput()</span>
<span class="nc" id="L383">            } catch (e: ClosedChannelException) {</span>
                // ignore
<span class="nc" id="L385">            } catch (e: IOException) {</span>
<span class="nc" id="L386">                throw e</span>
            }
        } finally {
<span class="fc" id="L389">            isOutputShutdown = true</span>
<span class="fc" id="L390">            networkWrite.releasable.release()</span>
        }
<span class="fc" id="L392">    }</span>

<span class="fc" id="L394">    private suspend fun read(b: ByteBuffer): Int  = lock.withLock {</span>
<span class="fc" id="L395">        read0(b)</span>
<span class="fc" id="L396">    }</span>


    /**
     * @implNote The `application` buffer must be empty or in a &quot;read state&quot; when exiting this method
     *
     * Buffer States:
     *  - Undefined:   Buffer Empty
     *  - Read State:  Bytes are read FROM the buffer
     *  - Write State: Bytes are written TO the buffer
     */
    private suspend fun read0(b: ByteBuffer): Int {
<span class="pc bpc" id="L408" title="1 of 4 branches missed.">        if(isInputShutdown &amp;&amp; !application.read.hasRemaining()) {</span>
<span class="fc" id="L409">            return -1</span>
        }

<span class="pc bpc" id="L412" title="2 of 4 branches missed.">        if (application.releasable.released || networkRead.releasable.released) {</span>
<span class="nc" id="L413">            return -1</span>
        }
<span class="fc" id="L415">        val app = application</span>
<span class="fc" id="L416">        val net = networkRead</span>

<span class="fc bfc" id="L418" title="All 2 branches covered.">        if(!sslEngine.session.isValid) {</span>
<span class="fc" id="L419">            startHandshake0() // &lt;-- flips application buffer to read mode</span>
        }

<span class="fc" id="L422">        val start = b.position()</span>

<span class="fc bfc" id="L424" title="All 2 branches covered.">        input@ while(b.hasRemaining()) {</span>
<span class="fc" id="L425">            application.toMode(ReadWriteBuffer.Mode.READ)</span>

            // Add remaining application data to the buffer
<span class="fc bfc" id="L428" title="All 2 branches covered.">            if(app.value.hasRemaining()) {</span>
<span class="fc" id="L429">                val count = min(app.value.remaining(), b.remaining())</span>
<span class="fc" id="L430">                b.put(b.position(), app.value, app.value.position(), count)</span>

<span class="fc" id="L432">                app.value.position(app.value.position() + count)</span>
<span class="fc" id="L433">                b.position(b.position() + count)</span>

<span class="fc" id="L435">                continue</span>
            }

            // Check if we're handshaking (could be initiated at any time, any number of times)
<span class="fc bfc" id="L439" title="All 2 branches covered.">            if(sslEngine.isHandshaking) {</span>
<span class="fc" id="L440">                handleHandshake0()</span>
<span class="fc" id="L441">                continue@input</span>
            }

<span class="fc bfc" id="L444" title="All 2 branches covered.">            if(net.value.hasRemaining()) {</span>

<span class="fc" id="L446">                while(true) {</span>
<span class="fc" id="L447">                    @Suppress(&quot;BlockingMethodInNonBlockingContext&quot;)</span>
<span class="fc" id="L448">                    val result = sslEngine.unwrap(net.read, app.write)</span>

<span class="pc bpc" id="L450" title="2 of 4 branches missed.">                    when (result.status!!) {</span>
                        SSLEngineResult.Status.BUFFER_UNDERFLOW -&gt; {
                            // Not enough data to read for the unwrap operation.

                            // If there's no more room to write, we need to expand the buffer.
                            // Otherwise, break out and allow for more data to be written.
<span class="nc bnc" id="L456" title="All 2 branches missed.">                            if(!net.write.hasRemaining()) {</span>
<span class="nc" id="L457">                                val buffer = net.releasable</span>
<span class="nc" id="L458">                                buffer.resize(buffer.value.capacity() + sslEngine.session.packetBufferSize)</span>
                            }

                            // TODO needs testing. Do we ever write back into this buffer?
                        }
                        SSLEngineResult.Status.BUFFER_OVERFLOW -&gt; {
<span class="nc" id="L464">                            handleOverflow(app)</span>
                        }
                        SSLEngineResult.Status.OK -&gt; {
<span class="fc" id="L467">                            break</span>
                        }
                        SSLEngineResult.Status.CLOSED -&gt; {
<span class="fc" id="L470">                            shutdownInput0()</span>
<span class="fc" id="L471">                            break@input</span>
                        }
                    }
                }
            } else {
<span class="fc" id="L476">                val count = ch.readSuspend(net.write, getReadTimeout())</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">                if(count == -1) {</span>
<span class="fc" id="L478">                    shutdownInput0()</span>
<span class="fc" id="L479">                    break@input</span>
                }
<span class="pc bpc" id="L481" title="1 of 2 branches missed.">                if (count == 0) {</span>
                    // return if no data read
<span class="nc" id="L483">                    break@input</span>
                }
            }
        }

        // In all cases the method exists with the application buffer in read mode or empty

<span class="fc bfc" id="L490" title="All 2 branches covered.">        return if(b.position() == start) {</span>
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">            if(isInputShutdown) -1 else 0</span>
        } else {
<span class="fc" id="L493">            b.position() - start</span>
        }
    }

<span class="fc" id="L497">    private suspend fun write(b: ByteBuffer) = lock.withLock {</span>
<span class="fc" id="L498">        write0(b)</span>
<span class="fc" id="L499">    }</span>

    private suspend fun write0(b: ByteBuffer) {
<span class="fc bfc" id="L502" title="All 2 branches covered.">        if(!sslEngine.session.isValid) {</span>
<span class="fc" id="L503">            startHandshake0()</span>
        }

<span class="fc bfc" id="L506" title="All 2 branches covered.">        while(b.hasRemaining()) {</span>

            // Check if we're handshaking (could be initiated at any time, any number of times)
<span class="fc bfc" id="L509" title="All 2 branches covered.">            if(sslEngine.isHandshaking) {</span>
<span class="fc" id="L510">                handleHandshake0()</span>
<span class="fc" id="L511">                continue</span>
            }

<span class="fc" id="L514">            wrap(src = b)</span>
        }
<span class="fc" id="L516">    }</span>

    /**
     * Returns true if the SSLEngine is handshaking.
     */
    private val SSLEngine.isHandshaking: Boolean
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">        get() = this.handshakeStatus != SSLEngineResult.HandshakeStatus.FINISHED</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">                &amp;&amp; this.handshakeStatus != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING</span>


    /**
     * Keeps track of the read/write state of the buffer.
     *
     * - *Read Mode* is defined as the state in which data is read from this buffer
     * - *Write Mode* is defined as the state in which data is written into this buffer
     */
<span class="fc" id="L532">    private class ReadWriteBuffer(</span>
<span class="fc" id="L533">        val releasable: ReleasableBuffer&lt;ByteBuffer&gt;,</span>
<span class="pc" id="L534">        var mode: Mode = Mode.READ</span>
<span class="fc" id="L535">    ) {</span>
        enum class Mode {
<span class="fc" id="L537">            READ, WRITE;</span>

<span class="fc bfc" id="L539" title="All 2 branches covered.">            fun isRead() = this === READ</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">            fun isWrite() = this === WRITE</span>
<span class="nc" id="L541">        }</span>

        /** Returns the buffer */
<span class="fc" id="L544">        val value: ByteBuffer get() = releasable.value</span>

        /** Returns the buffer if in read-mode, otherwise throws an exception */
        val read: ByteBuffer get() {
<span class="fc" id="L548">            toMode(Mode.READ)</span>
<span class="fc" id="L549">            return releasable.value</span>
        }

        /** Returns the buffer if in write-mode, otherwise throws an exception */
        val write: ByteBuffer get() {
<span class="fc" id="L554">            toMode(Mode.WRITE)</span>
<span class="fc" id="L555">            return releasable.value</span>
        }

        /**
         * Swaps the buffer between read and write mode, preparing it for the opposite operation.
         */
        fun swap(): ByteBuffer {
<span class="fc" id="L562">            val buffer = releasable.value</span>

<span class="fc bfc" id="L564" title="All 2 branches covered.">            if(mode.isRead()) {</span>
<span class="fc" id="L565">                mode = Mode.WRITE</span>

<span class="fc" id="L567">                return buffer.compact()</span>
            } else {
<span class="fc" id="L569">                mode = Mode.READ</span>

<span class="fc" id="L571">                return buffer.flip()</span>
            }
        }

        /**
         * Sets the buffer to the specified mode. If the buffer is already in the specified mode, this method does
         * nothing, otherwise it swaps the buffer to the opposite mode.
         */
        fun toMode(mode: Mode) {
<span class="fc bfc" id="L580" title="All 2 branches covered.">            if(this.mode != mode) {</span>
<span class="fc" id="L581">                swap()</span>
            }
<span class="fc" id="L583">        }</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>